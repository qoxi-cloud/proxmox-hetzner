name: CD

on:
  workflow_run:
    workflows: ["CI"]
    types:
      - completed
  workflow_dispatch:
    inputs:
      run_id:
        description: 'CI workflow run ID to deploy'
        required: true
        type: string

jobs:
  # Wait for all CI workflows to complete
  waitForCi:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' ||
      (github.event.workflow_run.conclusion == 'success' &&
       github.event.workflow_run.pull_requests[0] != null)
    permissions:
      checks: read
      pull-requests: read
      actions: read
    outputs:
      run_id: ${{ steps.run.outputs.id }}
      pr_number: ${{ steps.check.outputs.pr_number }}
    steps:
      - name: Set run ID
        id: run
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "id=${{ inputs.run_id }}" >> $GITHUB_OUTPUT
          else
            echo "id=${{ github.event.workflow_run.id }}" >> $GITHUB_OUTPUT
          fi

      - name: Get PR number
        id: check
        run: |
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "pr_number=" >> $GITHUB_OUTPUT
          else
            PR_NUMBER="${{ github.event.workflow_run.pull_requests[0].number }}"
            echo "pr_number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          fi

      - name: Wait for all CI checks
        if: steps.check.outputs.pr_number != ''
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.check.outputs.pr_number }};
            const maxAttempts = 60; // 10 minutes max
            const delayMs = 10000; // 10 seconds between checks

            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
              const { data: pr } = await github.rest.pulls.get({
                owner: context.repo.owner,
                repo: context.repo.repo,
                pull_number: prNumber
              });

              const { data: checks } = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.head.sha
              });

              const ciChecks = checks.check_runs.filter(check =>
                check.name.startsWith('CI') ||
                check.name.includes('shellcheck') ||
                check.name.includes('format') ||
                check.name.includes('commit')
              );

              console.log(`Attempt ${attempt}/${maxAttempts}:`);
              console.log(`Total CI checks: ${ciChecks.length}`);
              console.log(`Completed: ${ciChecks.filter(c => c.status === 'completed').length}`);
              console.log(`Successful: ${ciChecks.filter(c => c.conclusion === 'success').length}`);

              // Guard against empty array (Array.every returns true for empty arrays)
              if (ciChecks.length === 0) {
                // Fail fast on first attempt if no CI checks are found
                // This prevents timeout when workflow names change
                if (attempt === 1) {
                  throw new Error(
                    'No CI checks found for this PR. This likely means workflow/job names changed. ' +
                    'Update the check name filters in deployPr.yml waitForCi step.'
                  );
                }
                console.log('No CI checks found yet, waiting...');
                if (attempt < maxAttempts) {
                  console.log(`Waiting ${delayMs/1000}s before next check...`);
                  await new Promise(resolve => setTimeout(resolve, delayMs));
                }
                continue;
              }

              const allCompleted = ciChecks.every(check =>
                check.status === 'completed'
              );

              const allSuccess = ciChecks.every(check =>
                check.conclusion === 'success' || check.conclusion === 'skipped'
              );

              if (allCompleted) {
                if (allSuccess) {
                  console.log('All CI checks passed!');
                  return;
                } else {
                  const failed = ciChecks.filter(c =>
                    c.conclusion !== 'success' && c.conclusion !== 'skipped'
                  );
                  throw new Error(`CI checks failed: ${failed.map(c => c.name).join(', ')}`);
                }
              }

              if (attempt < maxAttempts) {
                console.log(`Waiting ${delayMs/1000}s before next check...`);
                await new Promise(resolve => setTimeout(resolve, delayMs));
              }
            }

            throw new Error('Timeout: CI checks did not complete or were not found');

  deployPr:
    runs-on: ubuntu-latest
    needs: waitForCi
    if: success()

    permissions:
      contents: write
      pull-requests: write
      actions: read
      repository-projects: read

    steps:
      - name: Download PR metadata
        uses: actions/download-artifact@v4
        with:
          name: pr-metadata
          path: /tmp/pr-metadata
          run-id: ${{ needs.waitForCi.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Download build artifact
        uses: actions/download-artifact@v4
        with:
          name: pve-install
          path: /tmp/build
          run-id: ${{ needs.waitForCi.outputs.run_id }}
          github-token: ${{ secrets.GITHUB_TOKEN }}

      - name: Read PR metadata
        id: pr
        run: |
          PR_NUMBER=$(cat /tmp/pr-metadata/pr_number)
          PR_BRANCH=$(cat /tmp/pr-metadata/pr_branch)
          PR_REPO=$(cat /tmp/pr-metadata/pr_repo)
          VERSION=$(grep '^VERSION=' /tmp/build/pve-install.min.sh | head -1 | sed 's/VERSION="//;s/"//')

          echo "number=${PR_NUMBER}" >> $GITHUB_OUTPUT
          echo "branch=${PR_BRANCH}" >> $GITHUB_OUTPUT
          echo "repo=${PR_REPO}" >> $GITHUB_OUTPUT
          echo "version=${VERSION}" >> $GITHUB_OUTPUT
          echo "filename=pve-install-pr.${PR_NUMBER}.min.sh" >> $GITHUB_OUTPUT

          # Check if this is a fork PR
          if [[ "$PR_REPO" != "${{ github.repository }}" ]]; then
            echo "is_fork=true" >> $GITHUB_OUTPUT
          else
            echo "is_fork=false" >> $GITHUB_OUTPUT
          fi

      - name: Checkout gh-pages
        uses: actions/checkout@v4
        with:
          ref: gh-pages
          fetch-depth: 0

      - name: Deploy PR script
        run: |
          FILENAME="${{ steps.pr.outputs.filename }}"

          # Copy minified PR script with unique name
          cp /tmp/build/pve-install.min.sh "${FILENAME}"

          # Configure git
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          # Add and commit
          git add "${FILENAME}"
          git commit -m "Deploy PR #${{ steps.pr.outputs.number }} test script" || echo "No changes to commit"
          git push origin gh-pages

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const prNumber = ${{ steps.pr.outputs.number }};
            const version = '${{ steps.pr.outputs.version }}';
            const filename = '${{ steps.pr.outputs.filename }}';
            const prBranch = '${{ steps.pr.outputs.branch }}';
            const prRepo = '${{ steps.pr.outputs.repo }}';
            const isFork = ${{ steps.pr.outputs.is_fork }};
            const repoOwner = context.repo.owner;
            const repoName = context.repo.repo;
            const scriptUrl = `https://${repoOwner}.github.io/${repoName}/${filename}`;

            const forkNote = isFork
              ? `\n\nüç¥ **Fork PR:** Templates will be loaded from [\`${prRepo}\`](https://github.com/${prRepo}/tree/${prBranch}).`
              : '';

            const tableRows = [
              '| Property | Value |',
              '|----------|-------|',
              `| **Version** | \`${version}\` |`,
              `| **Branch** | \`${prBranch}\` |`,
              `| **Source** | ${isFork ? `Fork: \`${prRepo}\`` : 'Same repo'} |`
            ].join('\n');

            const body = `## üß™ Test Build Available

            ${tableRows}

            ### Quick Install (for testing)

            \`\`\`bash
            bash <(curl -sSL ${scriptUrl})
            \`\`\`

            ### Direct Link

            üì• [${filename}](${scriptUrl})

            ---
            ‚ö†Ô∏è **Note:** This is a test build. Templates will be loaded from the \`${prBranch}\` branch.${forkNote}

            ü§ñ *This comment is automatically updated on each push to this PR.*`.replace(/^ +/gm, '');

            // Find and delete existing comment
            const { data: comments } = await github.rest.issues.listComments({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber
            });

            const botComment = comments.find(comment =>
              comment.user.type === 'Bot' &&
              comment.body.includes('üß™ Test Build Available')
            );

            if (botComment) {
              await github.rest.issues.deleteComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: botComment.id
              });
            }

            // Create new comment at the end
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: body
            });
